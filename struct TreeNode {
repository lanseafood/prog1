struct TreeNode {
              int item;         // The data in this node.
              TreeNode *left;   // Pointer to the left subtree.
              TreeNode *right;  // Pointer to the right subtree.
           }



 void postorderPrint( TreeNode *root ) {
           // Print all the items in the tree to which root points.
           // The items in the left subtree are printed first, followed 
           // by the items in the right subtree and then the item in the
           // root node.
        if ( root != NULL ) {  // (Otherwise, there's nothing to print.)
           postorderPrint( root->left );    // Print items in left subtree.
           postorderPrint( root->right );   // Print items in right subtree.
           cout << root->item << " ";       // Print the root item.
        }
     } // end postorderPrint()



 -------------

 struct TreeNode {
              // An object of type TreeNode represents one node
              // in a binary tree of strings.

         string item;      // The data in this node.
         TreeNode left;    // Pointer to left subtree.
         TreeNode right;   // Pointer to right subtree.

         TreeNode(string str) {
                // Constructor.  Make a node containing str.
            item = str;
            left = NULL;
            right = NULL;
         }

      };  // end struct Treenode



bool treeContains( TreeNode *root, string item ) {
                 // Return true if item is one of the items in the binary
                 // sort tree to which root points.   Return false if not.
             if ( root == NULL ) {
                   // Tree is empty, so it certainly doesn't contain item.
                return false;
             }
             else if ( item == root->item ) {
                   // Yes, the item has been found in the root node.
                return true;
             }
             else if ( item < root->item ) {
                   // If the item occurs, it must be in the left subtree.
                return treeContains( root->left, item );
             }
             else {
                   // If the item occurs, it must be in the right subtree.
                return treeContains( root->right, item );
             }
          }  // end treeContains()



void treeInsert(TreeNode *&root, string newItem) {
              // Add the item to the binary sort tree to which the parameter
              // "root" refers.  Note that root is passed by reference since
              // its value can change in the case where the tree is empty.
          if ( root == NULL ) {
                 // The tree is empty.  Set root to point to a new node containing
                 // the new item.  This becomes the only node in the tree.
             root = new TreeNode( newItem );
                     // NOTE:  The left and right subtrees of root
                     // are automatically set to NULL by the constructor.
                     // This is important!
             return;
          }
          else if ( newItem < root->item ) {
             treeInsert( root->left, newItem );
          }
          else {
             treeInsert( root->right, newItem );
          }
       }  // end treeInsert()

